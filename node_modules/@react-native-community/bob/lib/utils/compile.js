"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = compile;

var _path = _interopRequireDefault(require("path"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _chalk = _interopRequireDefault(require("chalk"));

var babel = _interopRequireWildcard(require("@babel/core"));

var _glob = _interopRequireDefault(require("glob"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

async function compile({
  root,
  source,
  output,
  options,
  flow,
  report
}) {
  const files = _glob.default.sync('**/*', {
    cwd: source,
    absolute: true,
    nodir: true,
    ignore: '**/__tests__/**,**/__fixtures__/**'
  });

  report.info(`Compiling ${_chalk.default.blue(String(files.length))} files in ${_chalk.default.blue(_path.default.relative(root, source))} with ${_chalk.default.blue('babel')}`);
  await Promise.all(files.map(async filepath => {
    const outputFilename = _path.default.join(output, _path.default.relative(source, filepath)).replace(/\.(js|tsx?)$/, '.js');

    await _fsExtra.default.mkdirp(_path.default.dirname(outputFilename));

    if (!/\.(js|tsx?)$/.test(filepath)) {
      // Copy files which aren't source code
      _fsExtra.default.copy(filepath, outputFilename);

      return;
    }

    const content = await _fsExtra.default.readFile(filepath, 'utf-8');
    const result = await babel.transformAsync(content, _objectSpread({
      babelrc: false,
      configFile: false,
      sourceMaps: true,
      filename: filepath
    }, options));

    if (result == null) {
      throw new Error('Output code was null');
    }

    let code = result.code;

    if (result.map) {
      const mapFilename = outputFilename + '.map';
      code += '\n//# sourceMappingURL=' + _path.default.basename(mapFilename);

      _fsExtra.default.writeFileSync(mapFilename, JSON.stringify(result.map));
    }

    await _fsExtra.default.writeFile(outputFilename, code);

    if (flow) {
      _fsExtra.default.copy(filepath, outputFilename + '.flow');
    }
  }));
  report.success(`Wrote files to ${_chalk.default.blue(_path.default.relative(root, output))}`);
}
//# sourceMappingURL=compile.js.map